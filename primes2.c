/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

/* name: maxnToNum
 * function() */
static int lcf1_maxnToNum (lua_State * L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L,0);
  
  /* maxn = tonumber(maxn) */
  lua_getfield(L,LUA_ENVIRONINDEX,"tonumber");
  lua_getfield(L,LUA_ENVIRONINDEX,"maxn");
  lua_call(L,1,1);
  lua_setfield(L,LUA_ENVIRONINDEX,"maxn");
  assert(lua_gettop(L) == 0);
  
  /* return true */
  lua_pushboolean(L,1);
  return 1;
  assert(lua_gettop(L) == 0);
}


/* warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static int lc_le(lua_State * L, int idxa, int idxb) {
  if (lua_type(L,idxa) == LUA_TNUMBER && lua_type(L,idxb) == LUA_TNUMBER) {
    return lua_tonumber(L,idxa) <= lua_tonumber(L,idxb);
  }
  else if (lua_type(L,idxa) == LUA_TSTRING && lua_type(L,idxb) == LUA_TSTRING) {
    /* result similar to lvm.c l_strcmp */
    return lua_lessthan(L,idxa,idxb) || lua_rawequal(L,idxa,idxb);
  }
  else if (luaL_getmetafield(L,idxa,"__le")||luaL_getmetafield(L,idxb,"__le")) {
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
    lua_call(L,2,1);
    const int result = lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else if (luaL_getmetafield(L,idxa,"__lt")||luaL_getmetafield(L,idxb,"__lt")) {
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-1 : idxb);
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-2 : idxa);
    lua_call(L,2,1);
    const int result = ! lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else {
    return luaL_error(L, "attempt to compare");
  }
}


#include <math.h>

/* __mod metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_mod(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - floor(lua_tonumber(L,idxa)/lua_tonumber(L,idxb))*lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mod")||luaL_getmetafield(L,idxb,"__mod")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* --[[ program that finds prime numbers --]]
   * m = require("math") */
  lua_getfield(L,LUA_ENVIRONINDEX,"require");
  lua_pushliteral(L,"math");
  lua_call(L,1,1);
  lua_setfield(L,LUA_ENVIRONINDEX,"m");
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* print("") */
  lua_getfield(L,LUA_ENVIRONINDEX,"print");
  lua_pushliteral(L,"");
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~") */
  lua_getfield(L,LUA_ENVIRONINDEX,"print");
  lua_pushliteral(L,"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* print(" This program finds prime numbers ") */
  lua_getfield(L,LUA_ENVIRONINDEX,"print");
  lua_pushliteral(L," This program finds prime numbers ");
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~") */
  lua_getfield(L,LUA_ENVIRONINDEX,"print");
  lua_pushliteral(L,"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* print("") */
  lua_getfield(L,LUA_ENVIRONINDEX,"print");
  lua_pushliteral(L,"");
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* print("Enter max number to search to:") */
  lua_getfield(L,LUA_ENVIRONINDEX,"print");
  lua_pushliteral(L,"Enter max number to search to:");
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* --[[ variable maxn is the maximum number that the program with search primes (starts at 2) --]]
   * maxn = io.read() */
  lua_getfield(L,LUA_ENVIRONINDEX,"io");
  lua_pushliteral(L,"read");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_setfield(L,LUA_ENVIRONINDEX,"maxn");
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* --[[ check to see if input, attempt to make it into integer, else exit --]]
   * if #maxn > 0 then */
  enum { lc1 = 0 };
  lua_pushnumber(L,0);
  lua_getfield(L,LUA_ENVIRONINDEX,"maxn");
  const double lc2 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc2);
  const int lc3 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc3);
  const int lc4 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc4) {
    
    /* local function maxnToNum()
     *         maxn = tonumber(maxn)
     *         return true
     *     end */
    lua_pushcfunction(L,lcf1_maxnToNum);
    assert(lua_gettop(L) - lc_nextra == 1);
    
    /* local err = pcall(maxnToNum) */
    lua_getfield(L,LUA_ENVIRONINDEX,"pcall");
    lua_pushvalue(L,(1 + lc_nextra));
    lua_call(L,1,1);
    assert(lua_gettop(L) - lc_nextra == 2);
    
    /* if err == false then */
    enum { lc5 = 2 };
    lua_pushboolean(L,0);
    const int lc6 = lua_equal(L,(2 + lc_nextra),-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc6);
    const int lc7 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc7) {
      
      /* print("Bad input") */
      lua_getfield(L,LUA_ENVIRONINDEX,"print");
      lua_pushliteral(L,"Bad input");
      lua_call(L,1,0);
      assert(lua_gettop(L) - lc_nextra == 2);
      
      /* print("Press <Enter> to end program") */
      lua_getfield(L,LUA_ENVIRONINDEX,"print");
      lua_pushliteral(L,"Press <Enter> to end program");
      lua_call(L,1,0);
      assert(lua_gettop(L) - lc_nextra == 2);
      
      /* _ = io.read() */
      lua_getfield(L,LUA_ENVIRONINDEX,"io");
      lua_pushliteral(L,"read");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,0,1);
      lua_setfield(L,LUA_ENVIRONINDEX,"_");
      assert(lua_gettop(L) - lc_nextra == 2);
      
      /* os.exit() */
      lua_getfield(L,LUA_ENVIRONINDEX,"os");
      lua_pushliteral(L,"exit");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,0,0);
      assert(lua_gettop(L) - lc_nextra == 2);
    }
    lua_settop(L,(lc5 + lc_nextra));
    assert(lua_gettop(L) - lc_nextra == 2);
  }
  else {
    
    /* else
     * os.exit() */
    lua_getfield(L,LUA_ENVIRONINDEX,"os");
    lua_pushliteral(L,"exit");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,0);
    assert(lua_gettop(L) - lc_nextra == 0);
  }
  lua_settop(L,(lc1 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* --[[ check if maxn is sane --]]
   * if maxn <= 1 then */
  enum { lc8 = 0 };
  lua_getfield(L,LUA_ENVIRONINDEX,"maxn");
  lua_pushnumber(L,1);
  const int lc9 = lc_le(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc9);
  const int lc10 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc10) {
    
    /* print("Bad input") */
    lua_getfield(L,LUA_ENVIRONINDEX,"print");
    lua_pushliteral(L,"Bad input");
    lua_call(L,1,0);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* print("Press <Enter> to end program") */
    lua_getfield(L,LUA_ENVIRONINDEX,"print");
    lua_pushliteral(L,"Press <Enter> to end program");
    lua_call(L,1,0);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* _ = io.read() */
    lua_getfield(L,LUA_ENVIRONINDEX,"io");
    lua_pushliteral(L,"read");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_setfield(L,LUA_ENVIRONINDEX,"_");
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* os.exit() */
    lua_getfield(L,LUA_ENVIRONINDEX,"os");
    lua_pushliteral(L,"exit");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,0);
    assert(lua_gettop(L) - lc_nextra == 0);
  }
  lua_settop(L,(lc8 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* print("The primes:") */
  lua_getfield(L,LUA_ENVIRONINDEX,"print");
  lua_pushliteral(L,"The primes:");
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* --[[ find primes --]]
   * for n = 2,maxn,1 do */
  lua_pushnumber(L,2);
  lua_getfield(L,LUA_ENVIRONINDEX,"maxn");
  lua_pushnumber(L,1);
  if (!(((lua_isnumber(L,-3) && lua_isnumber(L,-2)) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc11_var = lua_tonumber(L,-3);
  const double lc12_limit = lua_tonumber(L,-2);
  const double lc13_step = lua_tonumber(L,-1);
  lua_pop(L,3);
  enum { lc14 = 0 };
  while ((((lc13_step > 0) && (lc11_var <= lc12_limit)) || ((lc13_step <= 0) && (lc11_var >= lc12_limit)))) {
    
    /* internal: local n at index 1 */
    lua_pushnumber(L,lc11_var);
    
    /* for p = 2,math.ceil(math.sqrt(n)),1 do */
    lua_pushnumber(L,2);
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"ceil");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc18 = lua_gettop(L);
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"sqrt");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,(1 + lc_nextra));
    lua_call(L,1,LUA_MULTRET);
    lua_call(L,(lua_gettop(L) - lc18),1);
    lua_pushnumber(L,1);
    if (!(((lua_isnumber(L,-3) && lua_isnumber(L,-2)) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc15_var = lua_tonumber(L,-3);
    const double lc16_limit = lua_tonumber(L,-2);
    const double lc17_step = lua_tonumber(L,-1);
    lua_pop(L,3);
    enum { lc19 = 1 };
    while ((((lc17_step > 0) && (lc15_var <= lc16_limit)) || ((lc17_step <= 0) && (lc15_var >= lc16_limit)))) {
      
      /* internal: local p at index 2 */
      lua_pushnumber(L,lc15_var);
      
      /* if n % p == 0 then */
      enum { lc20 = 2 };
      lc_mod(L,(1 + lc_nextra),(2 + lc_nextra));
      lua_pushnumber(L,0);
      const int lc21 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc21);
      const int lc22 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc22) {
        
        /* break */
        break;
        assert(lua_gettop(L) - lc_nextra == 2);
      }
      lua_settop(L,(lc20 + lc_nextra));
      assert(lua_gettop(L) - lc_nextra == 2);
      
      /* if p == math.ceil(math.sqrt(n)) then */
      enum { lc23 = 2 };
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"ceil");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc24 = lua_gettop(L);
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"sqrt");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,(1 + lc_nextra));
      lua_call(L,1,LUA_MULTRET);
      lua_call(L,(lua_gettop(L) - lc24),1);
      const int lc25 = lua_equal(L,(2 + lc_nextra),-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc25);
      const int lc26 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc26) {
        
        /* print(n) */
        lua_getfield(L,LUA_ENVIRONINDEX,"print");
        lua_pushvalue(L,(1 + lc_nextra));
        lua_call(L,1,0);
        assert(lua_gettop(L) - lc_nextra == 2);
      }
      lua_settop(L,(lc23 + lc_nextra));
      assert(lua_gettop(L) - lc_nextra == 2);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc15_var += lc17_step;
    }
    lua_settop(L,(lc19 + lc_nextra));
    assert(lua_gettop(L) - lc_nextra == 1);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc11_var += lc13_step;
  }
  lua_settop(L,(lc14 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* print("Press <Enter> to end program") */
  lua_getfield(L,LUA_ENVIRONINDEX,"print");
  lua_pushliteral(L,"Press <Enter> to end program");
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* _ = io.read() */
  lua_getfield(L,LUA_ENVIRONINDEX,"io");
  lua_pushliteral(L,"read");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_setfield(L,LUA_ENVIRONINDEX,"_");
  assert(lua_gettop(L) - lc_nextra == 0);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


static int lc_pmain(lua_State * L) {
  luaL_openlibs(L);

  const lc_args_t * const args = (lc_args_t*)lua_touserdata(L, 1);
  lc_createarg(L, args);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);
  int i;
  for (i=1; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
  }
  int status2 = lua_pcall(L, args->c-1, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}


int main(int argc, const char ** argv) {
  lc_args_t args = {argc, argv};
  lua_State * L = luaL_newstate();
  if (! L) { fputs("Failed creating Lua state.", stderr); exit(1); }

  int status = lua_cpcall(L, lc_pmain, &args);
  if (status != 0) {
    fputs(lua_tostring(L,-1), stderr);
  }

  lua_close(L);
  return 0;
}


